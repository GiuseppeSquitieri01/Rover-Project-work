
# Rover Embedded System 

**Embedded Project – University of Salerno**  
Bachelor in Computer Engineering — A.Y. 2024/2025  

## Project Overview
This project implements the **embedded control system of an autonomous rover** using two **STM32G474RE microcontrollers** (Master and Slave) running **FreeRTOS**.  
It integrates multiple sensors and communication protocols to ensure a robust, safe, and real-time system.  

The rover was designed to:  
- Perform **real-time motion control** based on joystick inputs.  
- Handle **sensor fusion** (ultrasonic, IMU, temperature, encoders).  
- Guarantee **safety and fault tolerance** through error detection and emergency stop mechanisms.  
- Demonstrate the integration of **state modeling (Matlab/Stateflow)** with embedded C implementation.  

---

## Hardware Components
- **STM32G474RE (Nucleo-64)**: ARM Cortex-M4 MCU with FPU, 170 MHz.  
- **Communication Interfaces**:
  - **SPI**: data exchange between Master and Slave.  
  - **I2C**: sensor reading (MPU-6050 and external peripherals).  
  - **UART**: debugging and logging.  
- **Sensors**:
  - **HC-SR04 Ultrasonic (x3)** → obstacle detection.  
  - **MPU-6050 IMU** → orientation and motion control.  
  - **ADC** → analog signal acquisition.  
  - **Temperature sensor** → monitors the MCU board temperature;  
    if a critical threshold is exceeded, the system enters **emergency mode** to protect the hardware.  
  - **Encoders** → wheel speed and position.  
- **Actuators**:
  - **DC motors** driven through an **H-bridge** stage, controlled via PWM signals generated by the MCU timers.  

---

## Repository Structure
```

├── Master board project/
│   ├── Core/Inc        # Headers (FreeRTOS config, drivers, custom modules)
│   ├── Core/Src        # Application logic (controllers, communication, sensors, tasks)
│   ├── Drivers/        # HAL drivers and CMSIS
│   └── Middlewares/    # FreeRTOS code
│
├── Slave board project/
│   ├── Core/Inc
│   ├── Core/Src
│   ├── Drivers/
│   └── Middlewares/
│
├── Matlab/
│   ├── Stateflow models (.slx)
│   └── Auto-generated C code
│
└── Documentation/      # Final report and diagrams

````

---

## Software Architecture

### **Master Board**
- Reads **joystick inputs via I2C**.  
- Implements the **decision logic** for rover movement.  
- Communicates with the **Slave via SPI**, sending commands and receiving feedback.  
- Performs safety checks:
  - If an ultrasonic sensor repeatedly fails → stop the rover.  
  - If the BLE controller disconnects (signaled via I2C) → emergency stop.  
- Verifies consistency between **commanded velocity** and **encoder feedback**.  

### **Slave Board**
- Manages **encoders** and motor control.  
- Provides feedback on speed and position.  
- Enters **emergency mode** if communication with the Master times out.  

---

## FreeRTOS Scheduling – **Master Board**
The following tasks are effectively used:

- **Reading Task**  
  Periodically reads **sensors and inputs**:  
  - HC-SR04 (with error counters and *last valid distance* to avoid false stops),  
  - IMU (MPU-6050) via I2C,  
  - **Board temperature** via ADC → *if threshold exceeded ⇒ emergency mode request*,  
  - Joystick/user commands.  
  Publishes data to **queues** for other tasks. *Typical period*: 10–20 ms. *Priority*: medium.  

- **Communication Task**  
  Manages the **SPI link** with the slave:  
  - sends **setpoints** (velocity, direction, mode),  
  - receives **feedback** (encoder data, actuation status, diagnostic flags),  
  - monitors **timeout**: if no valid frame within Δt ⇒ **emergency**.  
  *Period*: 5–10 ms (event-driven/DMA). *Priority*: medium-high.  

- **Degraded Mode Task**  
  Activated under poor sensor quality (e.g., noisy ultrasonic, unstable IMU):  
  - reduces speed and max acceleration,  
  - increases safety margins,  
  - disables aggressive maneuvers,  
  keeping the rover functional but safe. *Trigger*: signal quality rules. *Priority*: medium.  

- **Emergency Mode Task**  
  Immediate **fail-safe** in case of:  
  - **over-temperature** on a board,  
  - lost **SPI link** (timeout),  
  - mismatch between **commanded velocity** and **encoder feedback**,  
  - sensors **out of range** for N consecutive samples,  
  - **BLE controller disconnect**.  
  Actions: cut setpoints, PWM=0, notify Slave, log over UART. *Priority*: high (preempts others).  

---

## FreeRTOS Scheduling – **Slave Board**


* **ReadingTask**
  Reads **encoders** (wheel speed/position) and local diagnostics (current, voltages if available).
  Filters and publishes data. *Period*: 1–5 ms. *Priority*: medium-high.

* **CommunicationTask**
  Maintains the **SPI session** with the Master:

  * receives setpoints/commands/modes,
  * sends encoder feedback and diagnostics,
  * checks **Master timeout** → if expired, signals **EmergencyTask**.
    *Period*: 5–10 ms (event-driven/DMA). *Priority*: high.

* **ActuationTask**
  Translates setpoints into **PWM** outputs for MCU timers and drives the **H-bridge** (direction + duty cycle):

  * ramping, limiters, anti-windup (if PID used),
  * consistency checks (no sudden reversals).
    *Period*: 1–5 ms. *Priority*: high.

* **EmergencyTask**
  Handles **local emergency state**:

  * forces PWM=0,
  * drives the H-bridge to safe condition,
  * ignores new setpoints until condition clears (requires Master reset).
    *Priority*: highest.

---

## Safety and Fault Tolerance

* **Over-temperature**: ADC threshold ⇒ emergency mode.
* **Ultrasonic sensors**: error counters; exceeding limit ⇒ stop. In normal operation, the last valid value is used to avoid oscillations.
* **Speed consistency**: compare **target velocity** (Master) vs **encoder feedback** (Slave) ⇒ persistent mismatch ⇒ emergency stop.
* **SPI timeout**: missing packets ⇒ emergency mode on both boards.
* **Degraded mode**: reduced performance but safe operation under poor signal quality.

---

## Build & Flash

### Requirements

* **STM32CubeIDE** (C/C++ toolchain, FreeRTOS support).
* **ST-LINK** programmer/debugger.

### Steps

1. Open the project in **STM32CubeIDE** (`.ioc` file included for configuration).
2. Build the project (`Project → Build All`).
3. Flash firmware on the STM32 board (`Run → Debug`).
4. Connect sensors and motors according to the documentation.
5. Monitor logs via UART.

---

## Authors

* Giuseppe Squitieri
* Andrea Scala
* Ermanno Troisi

---


Vuoi che ti prepari anche una versione **short & professional (5-6 righe in inglese)** pensata apposta per il CV, accanto al link GitHub?
```
